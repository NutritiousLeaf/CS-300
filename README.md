# CS-300

What was the problem you were solving in the projects for this course?
The problem I was solving was to design a course planner system that could read course information from a file, offer users the capability to list all courses in alphabetical order, and search for detailed information about a specific course, including its prerequisites. The issue wasn't just functional—reading files and displaying results—but structural: selecting the optimal data structure (vector, hash table, or binary tree) to store and manage the course data efficiently.

How did you approach the problem? Consider why data structures are important to understand.
I approached the issue by first writing detailed pseudocode explaining how the program would work for each of the three data structures. This allowed me to work out the performance considerations before starting to code. I compared all structures based on time complexity for operations like insertion, search, and print. Data structures were crucial to know because it would directly affect how efficiently the program could handle big data and generate readable, sorted output. Lastly, in the final code, I used a vector for convenience but also clarified why using a binary search tree (BST) would be optimal for scalability.

How did you overcome any roadblocks you encountered while going through the activities or project?
The biggest challenge was managing user input and making the program stable against wrong inputs. Initially, unexpected input (e.g., hitting a letter by accident for menu choices) caused the program to crash. I solved this by adding input checking with cin.fail() and clearing the input buffer when needed​. The second challenge was deciding how to keep the course list sorted. Since vector is not guaranteed to preserve order, I copied the course data into a temporary vector and sorted it first prior to displaying so that the program can meet the requirement without having to sacrifice underlying storage design.

How has your work on this project expanded your approach to designing software and developing programs?
Working on this project also made me realize the value of designing software not only for timely usability but future scalability and flexibilities. Pseudocoding early on forced me to think about program flow and data manipulation at a level higher than code before diving into the implementation. It also showed how important it is to anticipate user actions—both predictable and not so predictable—and add safeguards. I now understand more clearly why choosing the right data structure is so important to providing efficient operations and how slight changes (like BST's self-sorting) can have a major impact on performance and code readability.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I developed the habit of structuring my code in much neater and more modular fashion through this exercise. I segregated course management behavior into its own CoursePlanner class, making the main function cleaner and simpler to comprehend. I also improved readability by adding comments, following consistent naming conventions, and keeping narrow, focused responsibilities for each function. I also gained an understanding that producing flexible code is all about considering how new features (like changing to a different data structure) could be added later on without rewriting the whole thing. This experience made me a lot more careful in writing code that future developers—me included—can easily read, modify, and add onto.
